import zlib  # assume not using packfiles
import os
import sys

# USING STRACE:
# strace -f python3 topo_order_commits.py 2> strace.txt
# standard error output into text file
# cat strace.txt | grep "git" > git.txt
# all instances of git into text file
# no complaints or execve
# passes strace test


# part 5: print commit hashes in order generated by previous step
def topo_order_commits():
    branches = branch_names()
    hashes = branch_hash()
    sorted_commits = topological()
    commit_graph, _ = create_graph(hashes)

    # checking for sticky ends and starts
    sticky = False

    # goes thru and prints for each commit
    sorted_commit_length = len(sorted_commits)

    for i in range(sorted_commit_length):
        commit_hash = sorted_commits[i]

        child_branches = commit_graph[commit_hash].children
        parent_branches = commit_graph[commit_hash].parents

        if sticky:
            sticky = False
            branch_list = " ".join(child_branches)
            message = "=" + branch_list
            print(message)

        if commit_hash in branches:
            # sorted ensures deterministic behavior
            branch = sorted(branches[commit_hash])

        if branch:
            message = commit_hash + " " + " ".join(branch)
            print(message)
        # else:
        #     message = ""
        # print(message)

        if i < sorted_commit_length - 1:
            if sorted_commits[i + 1] not in parent_branches:
                sticky = True
                branch_list = " ".join(parent_branches)
                message = branch_list + '=\n'
                print(message)


class CommitNode:  # each commit is an instance of class
    def __init__(self, commit_hash):
        """
        :type commit_hash: str
        """
        self.commit_hash = commit_hash
        self.parents = set()
        self.children = set()


# part 1: find top level git directory
def find_git():
    # look for git in current directory
    while os.getcwd() != '/':
        cwd = os.getcwd()
        if (os.path.isdir(cwd + '/.git')):  # valid dir
            return cwd  # path
        # try parent dir
        os.chdir('../')
    # git cannot be found
    sys.stderr.write("Not inside a Git repository\n")
    exit(1)


# part 2: get list of local branch names
def branch_names():
    # find git directory
    git_dir = find_git()
    # dict of branch names
    branches = {}
    direc = os.path.join(git_dir, ".git", "refs", "heads")
    os.chdir(direc)
    for root, dirs, files in os.walk("."):
        for file_name in files:
            f = os.path.join(root, file_name)
            # head = f[f.rfind('heads/')+6:]
            raw_info = open(f, 'r').read()
            branch_hash = raw_info.strip()
            if branch_hash not in branches:
                branches[branch_hash] = []
            # branches[head] = branch_hash
            branches[branch_hash].append(f[2:])
            # branches[head] = commit

    return branches


# helper func that keeps track of hashes
def branch_hash():
    # hashes = {}
    hashes = set()
    # for branch, commit in branch_list.items():
    #     hashes.add()
    direc = os.path.join(find_git(), ".git", "refs", "heads")
    for root, dirs, files in os.walk(direc):
        for file_name in files:
            f = os.path.join(root, file_name)
            raw_info = open(f, 'r').read()
            branch_hash = raw_info.strip()
            hashes.add(branch_hash)
    return hashes


# part 3: perform depth-first search traversal, starting from branch head
# add the child hash to the parent node’s children
# add the parent hash to the child node’s parents


def create_graph(hashes):
    commit_graph = {}
    # find git directory
    git_dir = find_git()
    root_commits = set()
    # sorted ensures deterministic behavior
    branch_hash = sorted(hashes)
    while branch_hash:
        commit = branch_hash.pop()
        if commit not in commit_graph:
            commit_graph[commit] = CommitNode(commit)
            commit_dir = commit[:2]
            commit_file = commit[2:]
            # object direc
            direc = os.path.join(git_dir, ".git", "objects")
            path = os.path.join(direc, commit_dir, commit_file)
            compressed = open(path, 'rb').read()
            decompressed = zlib.decompress(compressed)
            parents = decompressed.decode('utf-8').split('\n')
            for line in parents:
                if "parent" in line:
                    parent = line.split()[1]
                    commit_graph[commit].parents.add(parent)
                    if parent not in commit_graph:
                        branch_hash.append(parent)
            # if no parent, is root commit!
            has_parent = False
            if commit_graph[commit].parents:
                has_parent = True
            if not has_parent:
                root_commits.add(commit)

    for commit in commit_graph:
        parents = list(commit_graph[commit].parents)
        for parent in parents:
            commit_graph[parent].children.add(commit)

    return commit_graph, root_commits


def topological():
    hashes = branch_hash()
    commit_graph, root_commits = create_graph(hashes)
    sorted_commits = []
    history = set()
    root_commits = list(root_commits)
    commits = []  # stack
    for root in root_commits:
        commits.append(root)
    # sorted allows for deterministic behavior
    for root_commit in sorted(root_commits):
        # stack is not empty
        while commits:
            # top of stack
            current = commits[-1]
            history.add(current)
            has_child = False
            children_list = list(commit_graph[current].children)
            # sorted ensures deterministic behavior
            new_child = False
            for child_id in sorted(children_list):
                # new child
                if child_id not in history:
                    new_child = True
                if new_child:
                    commits.append(child_id)
                    has_child = True
            if has_child is False:
                if current not in sorted_commits:
                    sorted_commits.append(current)
                commits.pop()
    return sorted_commits


if __name__ == '__main__':
    topo_order_commits()
